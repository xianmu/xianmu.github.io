<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="Pauca Sed Matura">
        <meta name="author" content="Xian Mu">
        <meta name="google-site-verification" content="1797926e4b62295d" />
        <title>RSA introduction</title>
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-4171915-2']);
          _gaq.push(['_trackPageview']);

          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
          </script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=http://chaoxuprime.com/mathjax_conf.js">
        </script>
        <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="stylesheet" href="/css/default.css" />
    </head>
    <body class="tex2jax_ignore">
      <header class="hide-on-print">
          <div id="blog-title">
              <a href="/">Pauca Sed Matura</a>
          </div>
      </header>
      <article>
          <h1 id="article-title">RSA introduction</h1>
          <br />
<div>
<p>1976年，Diffie和Hellman在其著名论文，New Directions in Cryptography<span class="citation" data-cites="diffie-hellman1976">[<a href="#ref-diffie-hellman1976">1</a>]</span>中提出了公钥密码学Public-Key Cryptography的概念，并指出PKC需要满足两个需求，一是在不安全信道上完成密钥交换，另一个是要实现电子签名。为满足第一个需求，作者基于离散对数问题提出了后来称为Diffie-Hellman的密钥交换算法。但是，对于第二个问题，他们没能给出一个完整的解决方案。这个重任留给了后来者。</p>
<p>1977年，MIT的Ron Rivest, Adi Shamir, Leonard Adleman三位大神基于大数分解问题提出了RSA算法<span class="citation" data-cites="rsa1977">[<a href="#ref-rsa1977">2</a>]</span>，成为第一个完整的公钥密码学算法，能够同时支持安全密钥传输和电子签名。40年的发展，特别是信息产业的飞速发展，RSA已成为最广泛使用的公钥密码系统之一，电子支付，email，www到处可见其身影。</p>
<p>本文简单介绍RSA相关知识，包括RSA算法理论部分，一些实现细节及优化，最后给出一个性能数据。</p>
<h1 id="rsa算法"><span class="header-section-number">1</span> RSA算法</h1>
<p>通常，一个密码学系统都至少有三个算法，即{<span class="math inline">\(KeyGen\)</span>, <span class="math inline">\(Enc\)</span>, <span class="math inline">\(Dec\)</span>}，其中<span class="math inline">\(KeyGen\)</span>用于生成密钥，<span class="math inline">\(Enc\)</span>加密明文得到密文，<span class="math inline">\(Dec\)</span>解密密文得到明文。RSA的这三个算法具体如下。</p>
<h2 id="keygen"><span class="header-section-number">1.1</span> <span class="math inline">\(KeyGen\)</span></h2>
<p>首先，<span class="math inline">\(KeyGen\)</span>接受一个安全参数<span class="math inline">\(\tau\)</span>，输出公私钥对{PK, SK}。安全参数<span class="math inline">\(\tau\)</span>通常表示着安全强度，在RSA中即公私钥的长度。具体步骤如下：</p>
<ol type="1">
<li>随机选择两个<span class="math inline">\(\tau\)</span>-bit的素数<span class="math inline">\(p\)</span>, <span class="math inline">\(q\)</span> (<span class="math inline">\(p \ne q\)</span>)，计算<span class="math inline">\(n = pq\)</span>;</li>
<li>计算欧拉函数<span class="math inline">\(\phi\)</span>(n) = <span class="math inline">\(\phi(p)\phi(q) = (p-1)(q-1)\)</span>;</li>
<li>选取一个小于且与<span class="math inline">\(\phi(n)\)</span>互素的整数<span class="math inline">\(e\)</span>，计算<span class="math inline">\(e\)</span>模<span class="math inline">\(\phi(n)\)</span>的乘法逆元<span class="math inline">\(d\)</span>，即<span class="math inline">\(ed \equiv 1\)</span> mod <span class="math inline">\(\phi(n)\)</span>;</li>
<li>PK = {<span class="math inline">\(n\)</span>, <span class="math inline">\(e\)</span>}, SK = {<span class="math inline">\(n\)</span>, <span class="math inline">\(d\)</span>}。</li>
</ol>
<p>其中，欧拉函数<span class="math inline">\(\phi(n)\)</span>表示小于等于<span class="math inline">\(n\)</span>且与<span class="math inline">\(n\)</span>互素的正整数个数。对于<span class="math inline">\(n\)</span>这样的semiprime(指可以表示为两个素数的乘积的数)，不难想明白<span class="math inline">\(\phi(n)=(p-1)(q-1)\)</span>。</p>
<h2 id="enc"><span class="header-section-number">1.2</span> <span class="math inline">\(Enc\)</span></h2>
<p>相对于<span class="math inline">\(KeyGen\)</span>，<span class="math inline">\(Enc\)</span>则要简单很多，它使用公钥PK加密消息<span class="math inline">\(m\)</span>，得到密文<span class="math inline">\(c\)</span>。 <span class="math display">\[ c = m^e\text{ mod }n \]</span></p>
<h2 id="dec"><span class="header-section-number">1.3</span> <span class="math inline">\(Dec\)</span></h2>
<p>解密算法<span class="math inline">\(Dec\)</span>也很简单，它使用私钥SK解密密文<span class="math inline">\(c\)</span>，得到明文<span class="math inline">\(m\)</span>。 <span class="math display">\[ m = c^d\text{ mod }n \]</span></p>
<h2 id="correctness"><span class="header-section-number">1.4</span> Correctness</h2>
<p><span class="math display">\[ m = Enc(Dec(m)) = m^{ed} \text{ mod } n\]</span></p>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>由Euler定理有，如果<span class="math inline">\(m\)</span>与<span class="math inline">\(n\)</span>互素，则<span class="math inline">\(m^{\phi(n)} \equiv 1 \text{ mod } n\)</span>，则 <span class="math display">\[ m^{ed} \text{ mod } n = m^{1+k\phi(n)} \text{ mod } n = (m^{\phi(n)})^k m \text{ mod } n = m\]</span></p>
</section>
<h2 id="security-reduction"><span class="header-section-number">1.5</span> Security Reduction</h2>
<p>首先，如果我们能快速分解大整数，则显然能够快速求出私钥<span class="math inline">\(d\)</span>，从而攻破RSA。反之呢，我们能否把攻破RSA规约到大整数分解素因数问题呢。</p>
<h1 id="more-implementation-details"><span class="header-section-number">2</span> More implementation details</h1>
<h2 id="big-number-operations"><span class="header-section-number">2.1</span> Big number operations</h2>
<p>如前所述，RSA基于大整数的运算，因而实现RSA离不开大数运算库，或者高精度计算库，NIST现在建议的<span class="math inline">\(\tau\)</span>取值是<span class="math inline">\(2048\)</span>或者<span class="math inline">\(3072\)</span>。RSA至少需要大整数的减法，乘法，比较，最大公约数gcd，模乘求逆，模幂，大素数生成等等功能。前几个操作的实现比较简单，gcd通过Euclidean算法实现，模幂运算通过反复平方法可以快速求得，模逆通过Extended-Euclidean算法求得。</p>
<h2 id="tau-bit-primes-generation"><span class="header-section-number">2.2</span> <span class="math inline">\(\tau\)</span>-bit primes generation</h2>
<p>大素数生成采用重复生成伪随机大整数然后做素性测试直到获得一个素数。</p>
<h2 id="speed-up-with-crt"><span class="header-section-number">2.3</span> Speed up with CRT</h2>
<p>按上面的描述，公私钥对都不需要大素数<span class="math inline">\(p, q\)</span>的配合，<span class="math inline">\(KeyGen\)</span>完成就可以销毁它们了。但实际上，具体实现中通常不销毁二者，而是利用中国剩余定理CRT计算几个相关的整数，从而加速解密过程。</p>
<h2 id="random-padding"><span class="header-section-number">2.4</span> Random padding</h2>
<p>以上介绍了基本的RSA算法，但其在实际应用中会有问题。不难发现，以上介绍的RSA算法是一种确定性的加密算法，即对于相同的明文将得到相同的密文。另一方面，结合前面对于攻击模型介绍可知，RSA不能应对选择密文攻击CCA，构造方法很简单。假定有密文：</p>
<p><span class="math display">\[ c = m^e \text{ mod } n\]</span></p>
<p>构造密文：</p>
<p><span class="math display">\[ c^\prime = 2^e \text{ mod } n\]</span></p>
<p>选择密文：</p>
<p><span class="math display">\[ C = cc^\prime = (2m)^e \text{ mod } n\]</span></p>
<p>将选择密文<span class="math inline">\(C\)</span>作为输入提供给解密算法即可得出明文<span class="math inline">\(2m\)</span>。</p>
<p>为解决这一问题，实际使用的RSA都会对明文先进行random padding，再进行加密。由于需要padding，<span class="math inline">\(\tau\)</span>-bit的密钥不能加密<span class="math inline">\(\tau\)</span>-bit的明文。同样的，嵌套地加密一个明文，密文会越来越长。以下介绍具体的padding算法。</p>
<h3 id="pkcs-1.5-padding"><span class="header-section-number">2.4.1</span> PKCS-1.5 padding</h3>
<h3 id="oaep"><span class="header-section-number">2.4.2</span> OAEP</h3>
<h1 id="benchmark"><span class="header-section-number">3</span> Benchmark</h1>
<p>本部分给出rsa算法的性能数据，如下图</p>
<figure>
<img src="/files/rsa_performance.png" alt="RSA-performance" /><figcaption>RSA-performance</figcaption>
</figure>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-diffie-hellman1976">
<p>[1] W. Diffie, M. Hellman, <strong>New directions in cryptography</strong>, IEEE Transactions on Information Theory. 22 (1976) 644–654.</p>
</div>
<div id="ref-rsa1977">
<p>[2] R. Rivest, A. Shamir, L. Adleman, <strong>A method for obtaining digital signatures and public-key cryptosystems</strong>, Communications of the ACM. 21 (1977) 120–126.</p>
</div>
</div>

</div>
<div class="hide-on-print">
<div class="info">Tags: cryptography. <!--<a href="/posts/2017-07-01-RSA-introduction.md">Source</a>.--></div>

<!--    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'chaoxu'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
-->
</div>

      </article>
      <footer class="hide-on-print">© 2017 - <script>document.write(new Date().getFullYear())</script> XianMu. Licensed under <a href="http://www.wtfpl.net/txt/copying/">WTFPL v2</a>. Template copy from <a href="http://chaoxuprime.com">ChaoXu</a>.</footer>

    </body>
</html>

</html>
