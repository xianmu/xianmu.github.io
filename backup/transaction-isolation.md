---
title: transaction isolation 
tags: transaction
---

Isolation即事务的隔离性，用于描述并发事务间的读写可见性。理想中的隔离性使得每个事务完全不感知其他并发事务的存在，仿佛只有这一个事务在执行一般，因为没有并发事务存在，所以也不会有race condition。实际上，要使得事务不感知并发事务需要付出比较大的代价，naive的办法就是在物理上任一时刻只允许一个事务执行，显然这种方法导致系统吞吐量极低，而且长事务会阻塞其他事务，资源利用率极低。为此提出了一系列放松的隔离性级别。

SQL标准定义了以下四种隔离级别，它们依序越来越严格，付出的代价也越来越大。

# Read Uncommitted

这个级别其实是没有隔离性，放在这里作为一个比较基准。一个事务可以读到另一个事务未提交的修改(dirty read)。这个级别显然有很多race condition的风险，实践中也不会用到该级别，相对于其他级别，它的性能也没有显著的优势。

# Read Committed

此级别没有dirty read的问题，事务只能读到其他事务已经提交的结果，未提交的结果不能读到。但是此级别两次执行相同的查询读到的数据可能不一样(nonrepeatable read)，因为两次查询中间可能另外的事务提交了修改。


# Repeatable Read

此级别不会有nonrepeatable read，一个事务提交前查询总是看到相同的数据。但是该级别有幻读(phantom read)的问题，及两次查询可能会读到新插入的数据。


# Serializable

此为最高级，即理想的隔离性，完全像只有一个事务在执行，不会有phantom read。
