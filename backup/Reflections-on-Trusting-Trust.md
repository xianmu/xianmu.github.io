---
title: Reflections on Trusting Trust
tags: security
---

Reflections on Trusting Trust是Ken Thompson获得1983年图灵奖时的获奖演说。文章不长，一共三页，除去一些致谢的内容，技术相关的内容大约只有两页。文章介绍了一种十分有趣的在C compiler中植入后门的方法(Ken Thompson Hack-KTH)。

# 故事

在说具体的技术前，先说说这个故事。

江湖传言，Unix开发出来后，很快就被安装在贝尔实验室供大家日常使用。很快的，大家发现总是有人偷偷登陆他们的账号，贝尔实验室的科学家们自然不是吃素的，他们review了unix源码，找到了后门，既然找到了问题，解决问题就自然而然了，他们修复了代码重新编译部署。

如果只是简单的在源码里面留这样一个review就能发现的后门，那这个故事就太简单了。果然，很快的，他们发现还是有人能够登陆他们的账号，问题没解决。这一次，问题变得麻烦起来，因为unix源码是没有问题的，能怀疑的点不多，他们猜测问题可能出在编译器上。经过检查，编译器也确实是有问题的，于是他们又重写了编译器，重新编译。

这一次，问题总该解决了吧。但是，重新编译出来的编译器仍然是有问题的。到这里，谁也说不清楚这里的后门是怎么来的了。

在图灵讲演里面，Ken Thompson给出了解释。这个后门确实是在编译器中，但是其实是在第一个实现中就已经加了这个后门。该后门在检测到自己在编译编译器时，会拷贝该后门插入正在编译的编译器中；另一方面，如果检测到正在编译unix login，则插入一个提权的后门。之后Ken Thompson删除了第一个实现的源码。所以说，其实所有的compiler都是有问题的，它们都是由第一个编译器编译出来的，无论怎么重写代码，只要用有问题的编译器，都会被植入这个后门。

# 技术

Ken Thompson将这个后门的实现分成三个步骤，如下：

1. 写一个自复制的代码，即写一段代码，运行后打印自己的源码；

2. 在C编译器中增加一段代码，该代码在检测到编译unix login命令时插入一个提权后门；

3. 在第二步的编译器中插入另一段代码，该代码在检测到编译C compiler时插入第二步的提权后门和后门生成器。

## Quine

如何写一个打印自己源码的C代码，是一个经典的C练习题，应该很多人都见过。但其实这个问题并不那么容易想到，反正我没能想出来。

## 2

## 3

## 4

这个手法可以无限扩展，感染调试器，反编译器，反编译的时候在输出中将植入的后门删除，等等。

## Experiment

意外发现有大神基于tcc重复了该实验，详尽[这里](https://ring0.me/2014/11/insert-backdoor-into-compiler/)

# 安全与信任

回到题目上来，Reflections on Trusting Trust，反思信任之信任。

如果编译器可能是有问题的(无意或者恶意)，那显然我们不能通过任何应用层的手段彻底解决这个问题。既然编译器可能是有问题的，那么其他依赖呢，如各种第三方库，软件栈的其他层呢，如操作系统，各种常用工具呢，硬件呢，如cpu等等。那我们能信任什么呢，难道要把所有依赖及工具都review一遍或者重新实现一遍，显然这不现实。

从好的方面讲，大范围传播的软件，很容易发现问题。但是，对于底层软件的信任也不能太理所当然。
